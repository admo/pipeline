<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Components</title>
<link rel="stylesheet" href="http://www.boost.org/doc/libs/1_55_0/doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Pipeline 1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Pipeline 1">
<link rel="prev" href="quick_start.html" title="Quick Start">
<link rel="next" href="how_to.html" title="How To">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="quick_start.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="how_to.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="pipeline.components"></a><a class="link" href="components.html" title="Components">Components</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="components.html#pipeline.components.glossary">Glossary</a></span></dt>
<dt><span class="section"><a href="components.html#pipeline.components.transformations">Transformations</a></span></dt>
<dt><span class="section"><a href="components.html#pipeline.components.open_segments">Open Segments</a></span></dt>
<dt><span class="section"><a href="components.html#pipeline.components.type_erasure">Type erasure</a></span></dt>
<dt><span class="section"><a href="components.html#pipeline.components.item_type_requirements">Item type
      requirements</a></span></dt>
<dt><span class="section"><a href="components.html#pipeline.components.scheduling">Scheduling</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pipeline.components.glossary"></a><a class="link" href="components.html#pipeline.components.glossary" title="Glossary">Glossary</a>
</h3></div></div></div>
<p>
        This section provides definitions of some commonly used terms throughout
        the documentation or library code:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <span class="bold"><strong>callable</strong></span>: A function pointer, function
            object, functor, bind expression or lambda. Basically, every <code class="computeroutput"><span class="identifier">f</span></code> is a callable if <code class="computeroutput"><span class="identifier">f</span><span class="special">(</span><span class="identifier">Args</span><span class="special">...)</span></code> is valid for some <code class="computeroutput"><span class="identifier">Args</span><span class="special">...</span></code>.
          </li>
<li class="listitem">
            <span class="bold"><strong>transformation</strong></span>: A method producing output
            items from input items. Precisely, it's a callable which signature matches
            to one of them described in section <a class="link" href="components.html#pipeline.components.transformations" title="Transformations">Transformations</a>
          </li>
<li class="listitem">
            <span class="bold"><strong>segment</strong></span>: A not necessarily terminated
            series of connected transformations.
          </li>
<li class="listitem">
            <span class="bold"><strong>plan</strong></span>: A terminated series of connected
            transformations: its input and output is specified.
          </li>
<li class="listitem">
            <span class="bold"><strong>task</strong></span>: A running segment. Tasks are scheduled
            on the thread pool.
          </li>
<li class="listitem">
            <span class="bold"><strong>upstream</strong></span>: Generally, the segment connected
            to the left of a segment. Specifically, it's the input queue of a task.
          </li>
<li class="listitem">
            <span class="bold"><strong>downstream</strong></span>: Generally, the segment connected
            to the right of a segment. Specifically, it's the output queue of a task.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pipeline.components.transformations"></a><a class="link" href="components.html#pipeline.components.transformations" title="Transformations">Transformations</a>
</h3></div></div></div>
<p>
        A transformation is a callable which receives one or more input items and
        produces one or more output items in turn. Depending on exactly how much
        items are read and produced on each call, transformations have different
        signatures:
      </p>
<pre class="programlisting"><span class="comment">// not exhaustive list of possible signatures</span>
<span class="identifier">Output</span> <span class="identifier">one_to_one</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Input</span><span class="special">&amp;</span> <span class="identifier">input</span><span class="special">);</span>
<span class="identifier">R</span>      <span class="identifier">one_to_n</span>  <span class="special">(</span><span class="keyword">const</span> <span class="identifier">Input</span><span class="special">&amp;</span> <span class="identifier">input</span><span class="special">,</span>           <span class="identifier">queue_back</span><span class="special">&lt;</span><span class="identifier">Output</span><span class="special">&gt;&amp;</span> <span class="identifier">downstream</span><span class="special">);</span>
<span class="identifier">Output</span> <span class="identifier">n_to_one</span>  <span class="special">(</span><span class="identifier">queue_front</span><span class="special">&lt;</span><span class="identifier">Input</span><span class="special">&gt;&amp;</span> <span class="identifier">upstream</span><span class="special">);</span>
<span class="identifier">R</span>      <span class="identifier">n_to_m</span>    <span class="special">(</span><span class="identifier">queue_front</span><span class="special">&lt;</span><span class="identifier">Input</span><span class="special">&gt;&amp;</span> <span class="identifier">upstream</span><span class="special">,</span> <span class="identifier">queue_back</span><span class="special">&lt;</span><span class="identifier">Output</span><span class="special">&gt;&amp;</span> <span class="identifier">downstream</span><span class="special">);</span>
</pre>
<p>
        Type legend:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <span class="bold"><strong>Input</strong></span>: type of input items
          </li>
<li class="listitem">
            <span class="bold"><strong>Output</strong></span>: type of output items
          </li>
<li class="listitem">
            <span class="bold"><strong>R</strong></span>: arbitrary return type
          </li>
</ul></div>
<p>
        Input items can be taken as <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code> (as above) or by value (if it's possible).
        Queue handles can be taken by value or by reference; a <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code> doesn't make much sense.
      </p>
<p>
        A transformation can be anything which is callable with any of the above
        arguments. This includes function pointers, function objects, functors, bind
        expressions and lambdas. Examples:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">length</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">input</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;)&gt;</span> <span class="identifier">length_f</span><span class="special">(</span><span class="identifier">length</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">inverse</span> <span class="special">=</span> <span class="special">[]</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">input</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">input</span> <span class="special">*</span> <span class="special">(-</span><span class="number">1</span><span class="special">);</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">add_5</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">add</span><span class="special">,</span> <span class="number">5</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">);</span>
</pre>
<p>
        Such transformations can be connected to appropriate segments using the
        <code class="computeroutput"><span class="special">|</span></code> operator. However, there are
        one restriction on bind expressions. Assume the following example:
      </p>
<pre class="programlisting"><span class="comment">// takes the square root of input if it's greater than `threshold`</span>
<span class="keyword">void</span> <span class="identifier">sqrt_if_greater</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">threshold</span><span class="special">,</span> <span class="identifier">queue_front</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&amp;</span> <span class="identifier">upstream</span><span class="special">,</span> <span class="identifier">queue_back</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;&amp;</span> <span class="identifier">downstream</span><span class="special">);</span>

<span class="keyword">auto</span> <span class="identifier">sqrt_if_greater_than_5</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">sqrt_if_greater</span><span class="special">,</span> <span class="number">5</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">,</span> <span class="identifier">_2</span><span class="special">);</span>
</pre>
<p>
        This case, the library has no way to find out the valid argument list of
        the <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
        template the bind has; it can't guess the <code class="computeroutput"><span class="identifier">value_type</span></code>
        of the downstream queue (<code class="computeroutput"><span class="keyword">float</span></code>).
        To overcome this limitation, the application must provide a hint:
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          If a callable is to be form an n-to-m transformation using bind and the
          input and output types are different, the type of the return value of the
          callable must match the output type.
        </p></td></tr>
</table></div>
<p>
        Which means, in the example above, <code class="computeroutput"><span class="identifier">sqrt_if_greater</span></code>
        must return <code class="computeroutput"><span class="keyword">float</span></code>. If the input
        and output types are the same, the library can get away with it.
      </p>
<p>
        You might wonder how an actual transformation looks like; take a look at
        the <a href="https://github.com/erenon/pipeline/blob/master/example/transformations.cpp" target="_top">example/transformations.cpp</a> file.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pipeline.components.open_segments"></a><a class="link" href="components.html#pipeline.components.open_segments" title="Open Segments">Open Segments</a>
</h3></div></div></div>
<p>
        Sometimes it's not feasible to assemble a pipeline in one go. One might want
        to build up smaller chunks and connect them dynamically. It's possible to
        create incomplete plans (i.e: <span class="emphasis"><em>segments</em></span>) using <code class="computeroutput"><a class="link" href="../boost/pipeline/make_idp30811344.html" title="Function template make">make()</a></code>:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">s2</span> <span class="special">=</span> <span class="identifier">ppl</span><span class="special">::</span><span class="identifier">make</span><span class="special">(</span><span class="identifier">length</span><span class="special">)</span> <span class="special">|</span> <span class="identifier">output</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">s1</span> <span class="special">=</span> <span class="identifier">ppl</span><span class="special">::</span><span class="identifier">from</span><span class="special">(</span><span class="identifier">lines</span><span class="special">)</span> <span class="special">|</span> <span class="identifier">trim</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">s</span>  <span class="special">=</span> <span class="identifier">s1</span> <span class="special">|</span> <span class="identifier">s2</span><span class="special">;</span>
</pre>
<p>
        Segments created by <code class="computeroutput"><span class="identifier">make</span></code>,
        such as <code class="computeroutput"><span class="identifier">s2</span></code> in the example
        are non-terminated segments (<a href="https://github.com/erenon/pipeline/blob/master/include/boost/pipeline/detail/open_segment.hpp" target="_top">include/boost/pipeline/detail/open_segment.hpp</a>)
        and not much of use on their own. To run them, they must be connected to
        an appropriate right-terminated but left-open segment (e.g: <code class="computeroutput"><span class="identifier">s1</span></code>).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pipeline.components.type_erasure"></a><a class="link" href="components.html#pipeline.components.type_erasure" title="Type erasure">Type erasure</a>
</h3></div></div></div>
<p>
        It might be necessary to take segments or plans as arguments, therefore a
        type is required. We always used the <code class="computeroutput"><span class="keyword">auto</span></code>
        keyword so far when it came to segments, because the actual type is rather
        complex and internal to the library. However, type erased handles are provided
        to be able to refer to them. <code class="computeroutput"><a class="link" href="../boost/pipeline/segment.html" title="Class template segment">segment&lt;Input,
        Ouput&gt;</a></code> can refer to any segment or plan which takes <code class="computeroutput"><span class="identifier">Input</span></code>s as input and produces <code class="computeroutput"><span class="identifier">Output</span></code>s. The tag <code class="computeroutput"><span class="identifier">terminated</span></code>
        denotes a closed end. A complete pipeline can be referenced as <code class="computeroutput"><span class="identifier">segment</span><span class="special">&lt;</span><span class="identifier">terminated</span><span class="special">,</span> <span class="identifier">terminated</span><span class="special">&gt;</span></code>
        or just simply <code class="computeroutput"><span class="identifier">ppl</span><span class="special">::</span><span class="identifier">plan</span></code>:
      </p>
<pre class="programlisting"><span class="identifier">ppl</span><span class="special">::</span><span class="identifier">segment</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;</span> <span class="identifier">s2</span> <span class="special">=</span> <span class="identifier">ppl</span><span class="special">::</span><span class="identifier">make</span><span class="special">(</span><span class="identifier">length</span><span class="special">);</span>
<span class="identifier">ppl</span><span class="special">::</span><span class="identifier">segment</span><span class="special">&lt;</span><span class="identifier">ppl</span><span class="special">::</span><span class="identifier">terminated</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">s1</span> <span class="special">=</span> <span class="identifier">ppl</span><span class="special">::</span><span class="identifier">from</span><span class="special">(</span><span class="identifier">lines</span><span class="special">)</span> <span class="special">|</span> <span class="identifier">trim</span><span class="special">;</span>
<span class="identifier">ppl</span><span class="special">::</span><span class="identifier">segment</span><span class="special">&lt;</span><span class="identifier">ppl</span><span class="special">::</span><span class="identifier">terminated</span><span class="special">,</span> <span class="identifier">ppl</span><span class="special">::</span><span class="identifier">terminated</span><span class="special">&gt;</span> <span class="identifier">s</span> <span class="special">=</span> <span class="identifier">s1</span> <span class="special">|</span> <span class="identifier">s2</span> <span class="special">|</span> <span class="identifier">output</span><span class="special">;</span>
</pre>
<p>
        Thanks to the type erased handles, it's easy to create interfaces expecting
        segments or plans:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">execute_plan</span><span class="special">(</span><span class="identifier">ppl</span><span class="special">::</span><span class="identifier">plan</span><span class="special">&amp;</span> <span class="identifier">p</span><span class="special">)</span>
<span class="special">{</span>
  <span class="identifier">ppl</span><span class="special">::</span><span class="identifier">thread_pool</span> <span class="identifier">pool</span><span class="special">{</span><span class="number">1</span><span class="special">};</span>
  <span class="keyword">auto</span> <span class="identifier">exec</span> <span class="special">=</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">run</span><span class="special">(</span><span class="identifier">pool</span><span class="special">);</span>
  <span class="identifier">exec</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span>
<span class="special">}</span>

<span class="identifier">ppl</span><span class="special">::</span><span class="identifier">segment</span><span class="special">&lt;</span><span class="identifier">ppl</span><span class="special">::</span><span class="identifier">terminated</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;</span> <span class="identifier">append_length</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ppl</span><span class="special">::</span><span class="identifier">segment</span><span class="special">&lt;</span><span class="identifier">ppl</span><span class="special">::</span><span class="identifier">terminated</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;&amp;</span> <span class="identifier">s1</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">s1</span> <span class="special">|</span> <span class="identifier">length</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        However, using these aliases does not come for free: it involves allocation
        of dynamic memory and indirection. It's recommended to use the <code class="computeroutput"><span class="keyword">auto</span></code> keyword instead wherever it's possible.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pipeline.components.item_type_requirements"></a><a class="link" href="components.html#pipeline.components.item_type_requirements" title="Item type requirements">Item type
      requirements</a>
</h3></div></div></div>
<p>
        Items pushed through the pipeline must be transferred from one transformation
        to the other and stored in queues. This imposes the following constraints
        on the <code class="computeroutput"><span class="identifier">T</span></code> type of such items:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><span class="identifier">T</span></code> must be <span class="bold"><strong>default
            constructible</strong></span>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">T</span></code> must be <span class="bold"><strong>movable</strong></span>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">T</span></code> must be <span class="bold"><strong>move
            assignable</strong></span>
          </li>
</ul></div>
<p>
        Example of such a type and verification of these requirements can be found
        in <a href="https://github.com/erenon/pipeline/blob/master/example/item_type_requirements_test.cpp" target="_top">example/item_type_requirements_test.cpp</a>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pipeline.components.scheduling"></a><a class="link" href="components.html#pipeline.components.scheduling" title="Scheduling">Scheduling</a>
</h3></div></div></div>
<p>
        The point of creating pipelines is to turn concurrency into parallelism by
        breaking a large process into smaller independent tasks and connecting them
        through message passing. Task can be then executed by different threads in
        parallel, thus achieving better throughput and &#8212; if done well &#8212; even
        lower latency.
      </p>
<p>
        Unfortunately, the scheduling mechanism currently employed by the library
        is far from great or clever. Below, the pros and cons of this solution is
        described before the planned improvements.
      </p>
<h3>
<a name="pipeline.components.scheduling.h0"></a>
        <span class="phrase"><a name="pipeline.components.scheduling.scheduling_as_done_currently"></a></span><a class="link" href="components.html#pipeline.components.scheduling.scheduling_as_done_currently">Scheduling
        as done currently</a>
      </h3>
<p>
        It's challenging to schedule tasks because using standard tools only, the
        library is not able to preempt them, therefore they might block for a long
        time. Also, even with the application writer involved, it's not convenient
        yielding from a task to an other in the same thread, e.g: if the downstream
        queue is full.
      </p>
<p>
        Such concerns can be resolved by using coroutines, but coroutine support
        is not yet implemented. Until then, the library uses an unbounded synchronized
        <a href="http://www.boost.org/doc/libs/1_56_0_b1/doc/html/thread/sds.html#thread.sds.synchronized_queues" target="_top"><code class="computeroutput"><span class="identifier">queue</span></code></a> to connect segments, a top-down
        approach to schedule tasks and employs blocking instead of yielding.
      </p>
<p>
        This is how it works: When the queue is being run, the tasks representing
        the plan are submitted to the thread pool, starting at the beginning of the
        pipeline. Order is important, this way the pool will execute the first <code class="computeroutput"><span class="identifier">pool_size</span></code> segment. Because of the reasons
        above, execution of a segment will not stop until the input queue is closed.
        If the input queue is empty, it will block until new item is available or
        it gets closed; this way no precious cycles are wasted spinning. The queue
        is unbounded, which means there is no blocking because of a full output queue.
        Assuming a pipeline of length <code class="computeroutput"><span class="identifier">segment_count</span></code>,
        if <code class="computeroutput"><span class="identifier">segment_count</span> <span class="special">&gt;</span>
        <span class="identifier">pool_size</span></code>, the <code class="computeroutput"><span class="identifier">pool_size</span>
        <span class="special">+</span> <span class="number">1</span></code>th
        segment will run only if the first segment is finished. This might affect
        latency badly. To avoid this, it's recommended to make the pool at least
        as large as the pipeline is long.
      </p>
<h3>
<a name="pipeline.components.scheduling.h1"></a>
        <span class="phrase"><a name="pipeline.components.scheduling.planned_improvements_of_scheduli"></a></span><a class="link" href="components.html#pipeline.components.scheduling.planned_improvements_of_scheduli">Planned
        improvements of scheduling</a>
      </h3>
<p>
        It's clear the scheme used above is not optimal. The offending reentrancy
        constraints can be mitigated by introducing coroutines. Running each task
        in it's own coroutine would make yielding possible: every time the upstream
        queue is empty or the downstream queue is full even after some spinning (assuming
        bounded lockfree queues).
      </p>
<p>
        Please refer to the <a href="http://www.slideshare.net/erenon/boostpipeline-scheduling-of-segments-36832455" target="_top">Pipeline.Scheduling</a>
        slides for more information.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Benedek Thaler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="quick_start.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="how_to.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
