<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Scheduling</title>
<link rel="stylesheet" href="http://www.boost.org/doc/libs/1_55_0/doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Pipeline 1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Pipeline 1">
<link rel="prev" href="open_segments.html" title="Open Segments">
<link rel="next" href="build_and_test_this_library.html" title="Build and Test this library">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="open_segments.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="build_and_test_this_library.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="pipeline.scheduling"></a><a class="link" href="scheduling.html" title="Scheduling">Scheduling</a>
</h2></div></div></div>
<p>
      The point of creating pipelines is to turn concurrency into parallelism by
      breaking a large process into smaller independent tasks and connecting them
      through message passing. Task can be then executed by different threads in
      parallel, thus achieving better throughput and &#8212; if done well &#8212; even lower
      latency.
    </p>
<p>
      Unfortunately, the scheduling mechanism currently employed by the library is
      far from great or clever. Below, the pros and cons of this solution is described
      before the planned improvements.
    </p>
<h2>
<a name="pipeline.scheduling.h0"></a>
      <span class="phrase"><a name="pipeline.scheduling.scheduling_as_done_currently"></a></span><a class="link" href="scheduling.html#pipeline.scheduling.scheduling_as_done_currently">Scheduling
      as done currently</a>
    </h2>
<p>
      It's challenging to schedule tasks because using standard tools only, the library
      is not able to preempt them, therefore they might block for a long time. Also,
      even with the application writer involved, it's not convenient yielding from
      a task to an other in the same thread, e.g: if the downstream queue is full.
    </p>
<p>
      Such concerns can be resolved by using coroutines, but coroutine support is
      not yet implemented. Until then, the library uses an unbounded synchronized
      <a href="http://www.boost.org/doc/libs/1_56_0_b1/doc/html/thread/sds.html#thread.sds.synchronized_queues" target="_top"><code class="computeroutput"><span class="identifier">queue</span></code></a> to connect segments, a top-down
      approach to schedule tasks and employs blocking instead of yielding.
    </p>
<p>
      This is how it works: When the queue is being run, the tasks representing the
      plan are submitted to the thread pool, starting at the beginning of the pipeline.
      Order is important, this way the pool will execute the first <code class="computeroutput"><span class="identifier">pool_size</span></code> segment. Because of the reasons
      above, execution of a segment will not stop until the input queue is closed.
      If the input queue is empty, it will block until new item is available or it
      gets closed; this way no precious cycles are wasted spinning. The queue is
      unbounded, which means there is no blocking because of a full output queue.
      Assuming a pipeline of length <code class="computeroutput"><span class="identifier">segment_count</span></code>,
      if <code class="computeroutput"><span class="identifier">segment_count</span> <span class="special">&gt;</span>
      <span class="identifier">pool_size</span></code>, the <code class="computeroutput"><span class="identifier">pool_size</span>
      <span class="special">+</span> <span class="number">1</span></code>th
      segment will run only if the first segment is finished. This might affect latency
      badly. To avoid this, it's recommended to make the pool at least as large as
      the pipeline is long.
    </p>
<h2>
<a name="pipeline.scheduling.h1"></a>
      <span class="phrase"><a name="pipeline.scheduling.planned_improvements_of_scheduli"></a></span><a class="link" href="scheduling.html#pipeline.scheduling.planned_improvements_of_scheduli">Planned
      improvements of scheduling</a>
    </h2>
<p>
      It's clear the scheme used above is not optimal. The offending reentrancy constraints
      can be mitigated by introducing coroutines. Running each task in it's own coroutine
      would make yielding possible: every time the upstream queue is empty or the
      downstream queue is full even after some spinning (assuming bounded lockfree
      queues).
    </p>
<p>
      Please refer to the <a href="http://www.slideshare.net/erenon/boostpipeline-scheduling-of-segments-36832455" target="_top">Pipeline.Scheduling</a>
      slides for more information.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Benedek Thaler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="open_segments.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="build_and_test_this_library.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
